<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Kirill Bogatikov - Json Parser</title>
        <link rel="stylesheet" href="/css/common.css"/>
        
        <script src="/js/jquery.js"></script>
        <script src="/js/common.js"></script>
        <script src="/js/projects.js"></script>
        <script>
            $(window).on("load", function() {
        	   PROJECT = loadProjectsJson("jparser");
        	   
        	   var div = $("#description");
        	   div.html(PROJECT.information[LANGUAGE] + div.html());
        	   
        	   $("#source-code").on("click", function() {
        	       openPage("https://github.com/KirillBogatikov/" + PROJECT.repository);
        	   });
            });
        </script>
    </head>
    <body>
        <a name="top" id="top"></a>
        <div id="header">
            <div class="left-text">
                <a id="go-index" href="/">На главную</a>
            </div>
            <div class="right-text">
                <a href="#parsing">Парсинг</a>
                <a href="/index.html#projects">Проекты</a>
            </div>
        </div>
        <div id="fast-scroll-top">
            <a href="#top" class="anchor-link"><img src="/img/anchor-top.png" alt="Scroll to top"/></a>
        </div>
        <div class="section" id="description">
            <p>JsonParser API реализован на языке Java 8 и используется для преобразования данных из формата <a href="https://tools.ietf.org/html/rfc7159">JSON</a> в объекты языка Java и обратно.
               API можно условно разделить на три составляющие:
               <ul>
                <li>Классы парсинга данных</li>
                <li>Классы представления данных</li>
                <li>Вспомогательные классы</li>
               </ul> 
            </p>
        </div>
        <a name="parsing"></a>
        <div class="section" id="parsing">
            <h1>Парсинг</h1>
            <p>Каждая крупная задача может быть разделена на несколько более мелких. Парсинг данных - довольно трудоемкий и сложный процесс, состоящий
               из нескольких этапов. В JsonParser этот процесс разбит на следующие этапы:
               <ul>
                <li>Удаление незначимых символов</li>
                <li>Токенизация JSON структуры</li>
                <li>Синтакический анализ структуры</li>
                <li>Формирование Java структуры</li>
               </ul> 
            </p>
            <p>К незначимым символам относятся пробельные символы, находящиеся вне строковых констант</p>
            <h3>Токены</h3>
            <p>Токенизация JSON структуры - процесс преобразования исходной JSON-структуры в последовательность
               понятных парсеру токенов. Токены в JsonParser хранятся в перечислении JsonTokens. Каждый токен строго
               и четко определяет какая именно сущность находится в даннм месте в исходной структуре. К примеру, такой
               JSON
               <code>[{ "name":"Mike" }]</code>
               будет токенизирован в следующую последовательность:
               <p><code>BEGIN_ARRAY, BEGIN_OBJECT, KEY, KEY_SEPARATOR, VALUE, END_OBJECT, END_ARRAY</code>.</p>
               Стоит отметить, что в процессе токенизации никоим образом не отлаливаются синтаксические ошибки. Так, некорректный
               JSON
               <code>[{ "name","Mike" }]</code>
               успешно интерпретируется в
               <p><code>BEGIN_ARRAY, BEGIN_OBJECT, KEY, VALUE_SEPARATOR, VALUE, END_OBJECT, END_ARRAY</code></p>
               Ошибки такого рода отлавливаются на этапе анализа структуры. 
            </p>
            <h3>Анализ</h3>
            <p>Анализ структуры производится для того, чтобы не начинать ресурсоемкий процесс формирования Java объектов зря.
               Конечно, разумнее производить анализ еще на этапе чтения, однако API должен предоставлять возможность обработки данных
               из самых разных источников. Порой, разработчику удобнее передать строку, в которой содержится JSON и получить её в виде иерархии объектов.
               К тому же, намного проще и надежнее анализировать не сам исходный текст, а последовательность токенов. Стандарт JSON очень строг и прост, а потому
               вариантов для появления ошибки не так уж и много. Возьмем, уже использованный ранее код:
               <code>[{ "name","Mike" }]</code>
               и последовательность его токенов
               <p><code>BEGIN_ARRAY, BEGIN_OBJECT, KEY, VALUE_SEPARATOR, VALUE, END_OBJECT, END_ARRAY</code></p>
               Согласно стандарту, JsonParser точно знает, что после BEGIN_ARRAY должно находиться како-либо значение, будь то число, строка или константа <code>(true/false/null)</code>. Так же
               на этом месте могут находиться составные типы данных: массив или объект. Да, действительно мы видим начало объекта. Здесь все правильно. Идем к следующему токену.
               После <code>BEGIN_OBJECT</code> может находиться только KEY - имя свойства этого объекта или "Ключ". Здесь тоже всё хорошо. Идем дальше. После KEY должен находиться токен
               <code>KEY_SEPARATOR</code>, обозначающий двоеточие - разделитель в паре "Ключ:Значение". Но на его месте стоит другой токен! И это ошибка!<br>
               На данном этапе необходимо прервать не только процесс анализа, но и парсинга в целом! Мы получили некорректный JSON и безопасно его преобразовать мы не сможем. 
            </p>
            <h3>JSON &rarr; Java</h3>
            <p>Формирование Java структуры - самый простой процесс. Мы уже знаем как нужно интепретировать конкретные куски исходных данных.
               Мы точно знаем, что если мы дошли до этой точки, структура корректна и мы можем безопасно её разобрать.
               Теперь необходимо каждому значение каждого токена исопльзовать корректным образом. <br/>
               Да, матерым разработчикам это в новинку, но в JsonParser каждый токен имеет значение. Это конкретный кусок исходной структуры, лишенный незначимых символов. 
               Такой &quot;финт ушами&quot; сделан для того, чтобы оптимизировать работу парсера. Нам не нужно будет несколько раз извлекать данные из
               исходной строки, занимая этим и процессорное время и память. Мы знаем за что отвечает токен, мы знаем как он выглядит в предосталенном JSON.<br/>
               Нам остается лишь для каждого <code>BEGIN_ARRAY</code> создать новый массив, <code>BEGIN_OBJECT</code> - объект, <code>NUMBER</code> преобразовать из строки в число и т.д. 
            </p>
        </div>
        <div class="section" id="storage">
            <h1>Хранение данных</h1>
            <h3>Иерархия</h3>
            <p>Абсолютно любая сущность формата JSON, будь то объект, число, массив или строка, обладают одной общей характеристикой - значением. Именно поэтому все классы хранения
               данных наследуются от одного абстрактного класса - JsonElement. Любой класс-наследник обладает тремя базовыми функциями - приведение к объекту, массиву или примитиву.
            </p>
            <p>
               JsonPrimitive - примитивное значение - число, строка, логическое значение или константа <code class="inline-code">null</code>. Класс JsonPrimitive обладает методами вроде  
            </p>
        </div>
        <div class="section" id="screenshots">
            <img width="200" height="300" src="img/noise.gif"/>
            <img width="300" height="200" src="img/noise.gif"/>
        </div>
        <div class="section" id="information">
            Проект JsonParser в данный момент находится в стадии разработки. За спиной немного наработок, но до первой версии осталось совсем чуть-чуть:
            исправить токенизатор и 
        </div>
        <div class="section" id="downloads">
            <p><button id="source-code" class="button-dark">Исходный код на GitHub</button></p>
            <p><button id="download-bin" class="button-dark">Скачать JP v.0.0.1.jar</button></p>
        </div>
    </body>
</html>